2) pom.xml (reports-service/pom.xml)

Incluye Spring Web, JasperReports e iText (PDF):

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.example</groupId>
  <artifactId>reports-service</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>reports-service</name>

  <properties>
    <java.version>17</java.version>
    <spring-boot.version>3.5.5</spring-boot.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>${spring-boot.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <dependencies>
    <!-- API REST -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- JasperReports -->
    <dependency>
      <groupId>net.sf.jasperreports</groupId>
      <artifactId>jasperreports</artifactId>
      <version>6.21.0</version>
    </dependency>

    <!-- PDF export (iText 2.x compatible con Jasper) -->
    <dependency>
      <groupId>com.lowagie</groupId>
      <artifactId>itext</artifactId>
      <version>2.1.7</version>
    </dependency>

    <!-- Tests opcionales -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <!-- Empaquetado jar ejecutable -->
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>

3) application.yml (perfil local + perfil docker)

reports-service/src/main/resources/application.yml:

server:
  port: 8083

spring:
  application:
    name: reports-service

# URL del products-service para entorno local
products:
  base-url: http://localhost:8082

---
spring:
  config:
    activate:
      on-profile: docker

# En Docker Compose nos comunicamos por el nombre del servicio
products:
  base-url: http://products-service:8082


Local: usa http://localhost:8082
Docker: usa http://products-service:8082 (service name del compose)

4) Plantilla Jasper products_report.jrxml

reports-service/src/main/resources/reports/products_report.jrxml

Campos: name (String), price (Double)

<?xml version="1.0" encoding="UTF-8"?>
<jasperReport xmlns="http://jasperreports.sourceforge.net/jasperreports"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://jasperreports.sourceforge.net/jasperreports
  http://jasperreports.sourceforge.net/xsd/jasperreport.xsd"
  name="products_report" pageWidth="595" pageHeight="842" columnWidth="555"
  leftMargin="20" rightMargin="20" topMargin="20" bottomMargin="20">

  <field name="name" class="java.lang.String"/>
  <field name="price" class="java.lang.Double"/>

  <title>
    <band height="60">
      <staticText>
        <reportElement x="0" y="0" width="400" height="30"/>
        <text><![CDATA[Reporte de Productos]]></text>
      </staticText>
    </band>
  </title>

  <columnHeader>
    <band height="20">
      <staticText>
        <reportElement x="0" y="0" width="300" height="20"/>
        <text><![CDATA[Nombre]]></text>
      </staticText>
      <staticText>
        <reportElement x="300" y="0" width="100" height="20"/>
        <text><![CDATA[Precio]]></text>
      </staticText>
    </band>
  </columnHeader>

  <detail>
    <band height="20">
      <textField>
        <reportElement x="0" y="0" width="300" height="20"/>
        <textFieldExpression><![CDATA[$F{name}]]></textFieldExpression>
      </textField>
      <textField>
        <reportElement x="300" y="0" width="100" height="20"/>
        <textFieldExpression><![CDATA[$F{price}]]></textFieldExpression>
      </textField>
    </band>
  </detail>

</jasperReport>

5) Controlador: obtiene productos y genera PDF

reports-service/src/main/java/com/example/reportsdomain/ReportController.java

package com.example.reportsdomain;

import net.sf.jasperreports.engine.*;
import net.sf.jasperreports.engine.data.JRMapCollectionDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import jakarta.servlet.http.HttpServletResponse;
import java.io.OutputStream;
import java.util.List;
import java.util.Map;

@RestController
public class ReportController {

    private final RestTemplate restTemplate = new RestTemplate();

    @Value("${products.base-url}")
    private String productsBaseUrl;

    @GetMapping("/reports/products")
    public void generateProductsReport(HttpServletResponse response) throws Exception {
        // 1) Traer datos del products-service
        ResponseEntity<List<Map<String, Object>>> resp = restTemplate.exchange(
                productsBaseUrl + "/products",
                HttpMethod.GET,
                null,
                new ParameterizedTypeReference<List<Map<String, Object>>>() {}
        );

        List<Map<String, Object>> data = resp.getBody();
        if (data == null || data.isEmpty()) {
            throw new IllegalStateException("No se encontraron productos para el reporte");
        }

        // 2) DataSource para Jasper (por Map)
        JRMapCollectionDataSource ds = new JRMapCollectionDataSource(data);

        // 3) Compilar plantilla JRXML
        JasperReport jasper = JasperCompileManager.compileReport(
                getClass().getResourceAsStream("/reports/products_report.jrxml")
        );

        // 4) Llenar reporte
        JasperPrint print = JasperFillManager.fillReport(jasper, null, ds);

        // 5) Responder PDF inline
        response.setContentType("application/pdf");
        response.setHeader("Content-Disposition", "inline; filename=products_report.pdf");
        try (OutputStream os = response.getOutputStream()) {
            JasperExportManager.exportReportToPdfStream(print, os);
            os.flush();
        }
    }
}


Nota: uso JRMapCollectionDataSource para pasar List<Map<>> directamente, sin crear una clase Product en el reports-service.

6) Probar local

Aseg√∫rate que products-service est√° corriendo en :8082 y devuelve algo en GET /products.

Arranca reports-service:

cd microservices/reports-service
mvn spring-boot:run


Abre en navegador:
http://localhost:8083/reports/products
Deber√≠as ver el PDF en l√≠nea.

Con curl para guardar:

curl -L http://localhost:8083/reports/products -o products_report.pdf

7) Integrar con el Gateway

En gateway/src/main/resources/application.yml aseg√∫rate de tener la ruta:

spring:
  cloud:
    gateway:
      routes:
        - id: reports-service
          uri: http://reports-service:8083   # en Docker
          predicates:
            - Path=/reports/**


Si est√°s sin Docker por ahora, puedes apuntar temporalmente a http://localhost:8083.

Prueba por gateway:
http://localhost:8080/reports/products

8) Dockerizar reports-service

reports-service/Dockerfile:

FROM openjdk:17-jdk-slim
WORKDIR /app
COPY target/reports-service-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8083
ENV SPRING_PROFILES_ACTIVE=docker
ENTRYPOINT ["java","-jar","app.jar"]


Activo el perfil docker para que use products.base-url: http://products-service:8082.

Compilar y construir imagen:

cd microservices/reports-service
mvn clean package -DskipTests
docker build -t reports-service:dev .

9) Actualiza tu docker-compose.yml

En la ra√≠z microservices/docker-compose.yml agrega (si no lo tienes):

version: '3.8'
services:
  users-service:
    build: ./users-service
    ports: ["8081:8081"]
    networks: [micro-net]

  products-service:
    build: ./products-service
    ports: ["8082:8082"]
    networks: [micro-net]

  reports-service:
    build: ./reports-service
    ports: ["8083:8083"]
    environment:
      - SPRING_PROFILES_ACTIVE=docker
    depends_on:
      - products-service
    networks: [micro-net]

  gateway:
    build: ./gateway
    ports: ["8080:8080"]
    depends_on:
      - users-service
      - products-service
      - reports-service
    networks: [micro-net]

networks:
  micro-net:
    driver: bridge


Levanta todo:

cd microservices
docker compose up --build


Prueba v√≠a gateway (Docker):

http://localhost:8080/reports/products

10) Pruebas r√°pidas y tips

Si ves 404 por gateway, revisa el Path y que /reports/** coincida con tu controlador (/reports/products).

Si ves 502/503 por gateway: el destino no responde ‚Üí ¬øarranc√≥ reports-service? ¬øel nombre reports-service coincide en compose?

Si ves 500 en reports-service: casi siempre es por campos de JRXML que no coinciden con las keys (name, price) o porque /products devolvi√≥ lista vac√≠a.

Para ver qu√© trae products-service, pega en navegador: http://localhost:8082/products.

üèÅ ¬øQu√© sigue?

(Opcional) Exportar HTML aparte del PDF.

(Opcional) Agregar par√°metros al reporte (fechas, filtros).

(Pro)** Conectar products-service a Oracle/MySQL y que el reporte saque datos reales de BD.

Si quieres, te dejo tambi√©n una versi√≥n HTML del endpoint y un .jrxml con estilos m√°s lindos. ¬øLe damos ese toque premium? üòé
