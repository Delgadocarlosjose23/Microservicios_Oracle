Desde la carpeta ra√≠z microservices/:

mkdir -p products-service/src/main/java/com/example/productsdomain
mkdir -p products-service/src/main/resources


Te debe quedar as√≠:

microservices/
‚îî‚îÄ‚îÄ products-service/
    ‚îú‚îÄ‚îÄ pom.xml
    ‚îú‚îÄ‚îÄ Dockerfile
    ‚îî‚îÄ‚îÄ src/
        ‚îú‚îÄ‚îÄ main/
        ‚îÇ   ‚îú‚îÄ‚îÄ java/
        ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ com/example/productsdomain/
        ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ProductsServiceApplication.java
        ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Product.java
        ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ProductController.java
        ‚îÇ   ‚îî‚îÄ‚îÄ resources/
        ‚îÇ       ‚îî‚îÄ‚îÄ application.yml

1) pom.xml (va en products-service/pom.xml)

M√≠nimo para exponer un API REST y empaquetar con Spring Boot.

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.example</groupId>
  <artifactId>products-service</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>products-service</name>
  <description>Products microservice</description>

  <properties>
    <java.version>17</java.version>
    <spring-boot.version>3.5.5</spring-boot.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>${spring-boot.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <dependencies>
    <!-- API REST -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Validaciones opcionales (@NotBlank, etc.) -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!-- Para reducir logs/ruido en pruebas -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
    </dependency>

    <!-- Lombok opcional (si lo usas, recuerda activar annotation processing) -->
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <optional>true</optional>
    </dependency>

    <!-- Tests (no imprescindibles para la demo) -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <!-- Empaqueta jar ejecutable -->
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>

2) application.yml (va en products-service/src/main/resources/application.yml)

Puerto propio y nombre del servicio.

server:
  port: 8082

spring:
  application:
    name: products-service


M√°s adelante, si quieres BD, aqu√≠ agregas spring.datasource y spring.jpa. Por ahora lo haremos en memoria para ir r√°pido en clase.

3) Clase principal (va en products-service/src/main/java/com/example/productsdomain/ProductsServiceApplication.java)
package com.example.productsdomain;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProductsServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProductsServiceApplication.class, args);
    }
}

4) Modelo Product (va en .../Product.java)

Sencillo, sin JPA para no depender de DB.

package com.example.productsdomain;

public class Product {
    private Long id;
    private String name;
    private Double price;

    public Product() {}

    public Product(Long id, String name, Double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public Double getPrice() { return price; }
    public void setPrice(Double price) { this.price = price; }
}

5) Controlador ProductController (va en .../ProductController.java)

CRUD en memoria (r√°pido para la demo). Auto-increment con AtomicLong.

package com.example.productsdomain;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

@RestController
@RequestMapping("/products")
public class ProductController {

    private final Map<Long, Product> db = new ConcurrentHashMap<>();
    private final AtomicLong seq = new AtomicLong(0);

    public ProductController() {
        // Semillas para probar de una
        create(new Product(null, "Laptop", 1200.0));
        create(new Product(null, "Mouse", 25.0));
    }

    @GetMapping
    public Collection<Product> list() {
        return db.values();
    }

    @GetMapping("/{id}")
    public Product get(@PathVariable Long id) {
        Product p = db.get(id);
        if (p == null) throw new NoSuchElementException("Product " + id + " not found");
        return p;
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Product create(@RequestBody Product product) {
        long id = seq.incrementAndGet();
        product.setId(id);
        db.put(id, product);
        return product;
    }

    @PutMapping("/{id}")
    public Product update(@PathVariable Long id, @RequestBody Product product) {
        if (!db.containsKey(id)) throw new NoSuchElementException("Product " + id + " not found");
        product.setId(id);
        db.put(id, product);
        return product;
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable Long id) {
        db.remove(id);
    }
}


Para errores m√°s ‚Äúbonitos‚Äù, luego agregamos un @ControllerAdvice. Por ahora, directo y a matar.

6) Dockerfile (va en products-service/Dockerfile)

Para ejecutar en contenedor f√°cilmente.

FROM openjdk:17-jdk-slim
WORKDIR /app
COPY target/products-service-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8082
ENTRYPOINT ["java","-jar","app.jar"]

7) Compilar y correr
Local (sin Docker)

Desde microservices/products-service:

mvn clean package -DskipTests
java -jar target/products-service-0.0.1-SNAPSHOT.jar


Ver√°s en logs que levanta en :8082.

Probar con curl
# Listar
curl http://localhost:8082/products

# Crear
curl -X POST http://localhost:8082/products \
  -H "Content-Type: application/json" \
  -d '{"name":"Teclado","price":15.5}'

# Ver uno
curl http://localhost:8082/products/1

# Actualizar
curl -X PUT http://localhost:8082/products/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"Laptop Gamer","price":1800.0}'

# Borrar
curl -X DELETE http://localhost:8082/products/1 -i

Con Docker
mvn clean package -DskipTests
docker build -t products-service:dev .
docker run --rm -p 8082:8082 products-service:dev

8) Conectar en el Gateway (cuando lo tengas)

En gateway/src/main/resources/application.yml agrega una ruta:

spring:
  cloud:
    gateway:
      routes:
        - id: products
          uri: http://products-service:8082   # nombre del servicio en docker-compose
          predicates:
            - Path=/products/**


Si a√∫n no usas Docker Compose, mientras tanto puedes apuntar a http://localhost:8082.



+---------------------------------------------+--------------------------------------------+

Ejemplo comando (si usas Spring Boot CLI):

spring init -d=cloud-gateway,actuator -g=com.example -a=gateway gateway


Eso te genera la carpeta gateway/.

2Ô∏è‚É£ Configuraci√≥n en application.yml

üìÇ gateway/src/main/resources/application.yml

server:
  port: 8080   # El gateway escucha en este puerto

spring:
  application:
    name: api-gateway

  cloud:
    gateway:
      routes:
        # Ruta para Users Service
        - id: users-service
          uri: http://users-service:8081
          predicates:
            - Path=/users/**

        # Ruta para Products Service
        - id: products-service
          uri: http://products-service:8082
          predicates:
            - Path=/products/**

        # Ruta para Reports Service
        - id: reports-service
          uri: http://reports-service:8083
          predicates:
            - Path=/reports/**

